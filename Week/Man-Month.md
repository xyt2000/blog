# 人月神话

## 第一印象

​	第一次看到人月神话这样的名字我是比较困惑的，我首先是想到了郭沫若先生写的《静夜》一诗，诗里有这样一句——“怕会有鲛人在岸，对月流珠。”，这句诗里有人，有月，有神话，倒是很契合人月神话这个名字，但我忘了一件事，那就是Brooks博士不是中国人。何为人月？一个程序员干一个月，就是一个人月，何为神话？十个程序员干一个月和一个程序员干十个月，都是十个人月，但如果这两个十个人月能划等号，那就是神话。
我会在这篇读书笔记中记录一些书中我印象比较深的内容，并结合一点点我四年本科中少的可怜的开发经验，写一点个人的理解。

## 为什么我们要讨论这个

​	讨论这个话题的目的其实很简单很朴实，那就是为了能尽可能开发优秀的软件，大一的时候，我们院的一位老教授就引用了Brooks博士的这样一句话： “像巨兽在泥潭中作垂死挣扎,挣扎得越猛,泥浆就沾得越多,最后没有一个野兽能够逃脱淹没在泥潭中的命运。”，而这个“泥潭巨兽说”被我和我的同学们调侃了四年，这只巨兽总是在各种课程设计的最后阶段出现，是我们提升GPA的一位重要拦路虎。

## 关于人月

​	回归到人月神话这个主话题里，Brooks最想表达给我们的思想是：不要相信人员数量和时间是可以互相替换的。也许在数据结构的图这一章里我们学习了关键路径相关的概念，但是那种调度方式的前提是每条路径的时间都是确定的，但是在软件工程这一学科中，我们往往缺乏对数据估计的统计，理想的里程碑总是因为各种原因被滞后，我在大二的时候参与了大创比赛，这个比赛的准备时间还算比较长的，也是我大学阶段接触的第一个项目，但是直到最后我们也没做出什么正经东西，因为我们总是觉得我们能在每个节点之前能够搞定一些事。

​    作者另外的一个观点在我看来是比较具有争议性的，那就是为进度落后的项目增加人手，只会让进度更加落后，作者认为这增加了总体的任务工作量：现有的项目可能因为要重新分配而中断，培训新人，进行额外的沟通都需要时间。但是我觉得其实事情也可能不完全是这样，很重要的一点是增加什么样的人手，如果这样的人手能带来一些变革的技术和方法，虽然确实是增加了以上三个方面的工作量，但是却降低了项目原本的工作量。

## 关于团队

​	我十分认可作者在文中给我们一种程序员团队的设计——外科医生团队，这样的团队需要这样几种成员，首席程序员及其副手，人事管理员，文档编辑，维护记录的程序职员，工具维护人员，测试人员以及语言专家，外加文秘。

一拥而上的开发是低效的，这样的组队方式提供了一种既能获取少数头脑产生的产品完整性，又能通过协作提高生产率，同时减少沟通的工作量。

我在大四的时候作为组长做了一个数据分析的课程设计，几乎所有的需求和开发技术都是我自己决定的，最终我们仅用很短的时间就提交了一个质量在平均线上的作品，而在我大三参与的课设中，我们组的四个人花了很多时间去讨论，随后花了大量时间去编程，可以说是劳民伤财了，但最后的成绩也就是一般的水平，所以思绪少也不一定是坏事。

## 关于文档

​    Brooks教授认为，在海量的文件中，少数的文档是关键的枢纽，每个项目经理的工作都围绕着它们运转，无论是大型项目还是小型项目，在项目早期文档都需要规范化，因为每个文档本身都需要在后来的开发中担当着检查列表或者数据库的功能。不仅如此，在项目开发的过程中，文档是一个交流工具，使得各种计划和决策得到交流。

​    对于我来说，如果给我本科的各个课程排一个地位，我会把软件工程需求和软件体系结构排在C++的上面，这两门所谓的文档课对我的帮助很大，因为我参与的每一个项目都要写好几个文档。众所周知其实很多课设、比赛的判分依据是文档的质量，当然这只是出于功利的角度。不过就算是出于保障软件的质量角度，文档的重要性也毋庸多言，救我的经验而言，好的项目文档不一定很看，但文档难看的项目绝对不可能好。

## 关于变更维护

​    斯宾塞．约翰逊先生在《谁动了我的奶酪？ 》中就提出了” 唯一不变的变化”，Brooks博士也表示：在软件开发的过程中唯一不变的就是变化本身，文中还引用到了熵这一化学概念，熵代表这混乱度，系统软件开发是减少熵的过程，而软件维护是提高熵的过程，无论我们多努力，也只能放缓系统往非稳态退化的过程。

​    在这里我又想到了在化学中和熵增熵减里关系特别密切的一个概念，那就是化学平衡里的勒夏特列原理，具体内容为：如果改变可逆反应的条件（如浓度、压强、温度等），化学平衡就被破坏，并向减弱这种改变的方向移动，这是一种逆反馈机制，我们在软件维护中可能也总会出现一些逆反馈，你越想让这个软件更加易用，你在这个方面下的努力越多，最终软件维护起来就越来越麻烦。

## 关于“没有银弹”

每一个软件工程相关的老师都会和你说这个故事，那就是狼人和银弹的故事，狼人只能通过银弹去杀死，但是在软件工程的领域往往没有银弹，而作者Brooks先生给我们足够令人信服的答案，那就是这一切的根源来自软件本身，是无法规避的一些本质上的问题，主要是软件的四个内在特性：

复杂度，软件确实是一件很复杂的事物，它是很多复杂元素非线性的添加。很多数学模型可以规避复杂度，但当复杂度就是事物本质特性时就很难行得通。

一致性，软件不是你从真空中创造的，开发一个软件是建立在以往的种种技术之上的，这些技术来源于人，而不是上帝。

可变性，用户总是有各种各样的想法，硬件也总是在不断变化，无论是从物理上还是逻辑上，软件的可变性的特别的强。

不可见性，我们可以用用例图、流程图、程序图等等成百类图去描述软件，但其实这些方法都如同盲人摸象一般，无法完整呈现软件的所有特征，就算是结合起来一起看，你还是会发现很多内容是重复的，很多信息是没用的，想要通过图去看懂一个软件依旧是很难的。

我很同意作者提出的这些观点，作者认为，没有银弹，甚至一直都不会有。很多质疑的想法在这些年不断涌现，但时至今日这些所谓的反驳远远没有“没有银弹”给大家带来的震撼和影响大。或许某种程度上大家也都认可没有银弹。也许未来AI能带给我们一些新的东西，但是结合人类发展的历史来看，很多事当它真正实现的时候早已不是我们本来预想的样子，举个例子，人类从古代就想像鸟儿一样飞翔，后来我们确实可以通过飞机飞往世界各地了，但我们还是无法像鸟儿一样飞翔。也许有一天真的有银弹出现，但那个时候可能狼人也不是我们先自的这种狼人了。

## 总结

​    总结就是规范地写文档和代码，前人的经验可能有时候对有时候错，但是规范写文档和代码会让你自己和你的团队成员都开心不少。